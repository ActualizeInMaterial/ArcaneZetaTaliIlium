These are the things that are decided to be used, one way or another.
Things that are depreciated or obsolete won't be here.


//1. sorted elements will be searched via divide et impera algorithm
//	- ie. keys even though not necessarily consecutive will be kept in sorted order and thus 
//	when searching for one, we will find it using divide et impera
//	- it's presumably easier than implementing a Btree
1. using bdb so it's doing that for us
	
	 
2. using DejaVu Sans Mono 14, in eclipse for editing (General->Appearance->Colors and Fonts)

3. methods will usually return TRUE if already existed; false otherwise; but they will not fail, if they do they throw exception using RunTime.thro();

4. give almost no regard to efficiency and size; give most regard to accessibility and consistency; also use explicitize(whatever) assumptions ie. RunTime.assumedTrue(x==y);


5. how to throw exceptions:
-a) if something throws an exception with "throw" keyword instead of RunTime.thro(); then this exception must be <caught and re-thrown>(aka wrapped) as follows:
	try {
			throw new IOException("tesT")://something that throws with throw keyword
	}catch(Throwable t) {//must use Throwable to make sure we don't miss some
		RunTime.throWrapped(t);
	}
	
	-if we don't wrap it, then when something throws with the "throw" keyword any chained/postponed exceptions from before will be overwritten and also exceptions thrown 
	with the throw keyword before(they will also be overwritten aka ignored and not reported); so only last thrown exception is reported
	
-b) to throw a postponed exception use RunTime.throPostponed() and later to recall all thrown exceptions use RunTime.throwAllThatWerePosponed(); 
	and they will be java thrown at that point (chained)
	
	
-c) to catch a specific exception, that is to test if that specific exception occurred you only have to catch(Throwable t) (so that means you catch once) for any and every test
    for example:
    try {
			try {
				Factory.init( ml2, params1 );//assuming this throws an already wrapped BadCallError - no matter in how many layers of wraps
			} catch ( Throwable t ) {
				RunTime.throWrapped( t );//we wrap it again just for fun; doesn't need to be wrapped at all actually, can contain zero wraps
			}
	} catch ( Throwable t ) {
			if ( RunTime.isThisWrappedException_of_thisType( t, BadCallError.class ) ) {
				//yes it is exactly BadCallError 
			}
			if ( RunTime.isThisWrappedException_of_thisType( t, Exception.class ) ) {
				//yes it is exactly Exception
			}
			if ( RunTime.isThisWrappedException_of_thisType( t, Error.class ) ) {
				//yes it is exactly Error, note that although BadCallError extends Error, if you caught BadCallError above, you will NOT catch it here as just Error.class
				//why? because this only tests for exactly that specific exception, no subclass or superclass of it!
			}
	} 
	NOTE: that you cannot test for a subclass of ie. Error, you can only test specifically for the named class (though it's easy to make a method for this, will do when needed) 
	
6. any classes that want to have init and deInit of resources ie. db-related should inherit Initer class and use Factory class to get new instance and init it
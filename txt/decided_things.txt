These are the things that are decided to be used, one way or another.
Things that are depreciated or obsolete won't be here.

TODO: update these

1. using bdb native 
	
	 
2. using DejaVu Sans Mono 14, in eclipse for editing (General->Appearance->Colors and Fonts)

3. methods will usually return TRUE if already existed; false otherwise; but they will not fail, if they do they throw exception using RunTime.thro();

4. give almost no regard to efficiency and size; give most regard to accessibility and consistency; 
also state your assumptions ie. assert (x==y);


5. how to throw exceptions:
-a) UPDATE: the following is done automatically by AspectJ, so don't do it manually
	---------
    if something throws an exception with "throw" keyword instead of RunTime.thro(); then this exception must be <caught and re-thrown>(aka wrapped) as follows:
	try {
			throw new IOException("tesT")://something that throws with throw keyword
	}catch(Throwable t) {//must use Throwable to make sure we don't miss some
		RunTime.throWrapped(t);
	}
	
	-if we don't wrap it, then when something throws with the "throw" keyword any chained/postponed exceptions from before will be overwritten and also exceptions thrown 
	with the throw keyword before(they will also be overwritten aka ignored and not reported); so only last thrown exception is reported
	
-b) to throw a postponed exception use RunTime.throPostponed() and later to recall all thrown exceptions use RunTime.throwAllThatWerePosponed(); 
	and they will be java thrown at that point (chained)
	
	
-c) to catch a specific exception, that is to test if that specific exception occurred you only have to catch(Throwable t) (so that means you catch once) for any and every test.
    The following code is for testing only for one specific exception if it was thrown or not:
    //5 parts needed
    try {
			try {
				Factory.init( ml2, params1 );//assuming this throws an already wrapped BadCallError - no matter in how many layers of wraps
			} catch ( Throwable t ) {
				RunTime.throWrapped( t );//we wrap it again just for fun; doesn't need to be wrapped at all actually, can contain zero wraps
			}
	} catch ( Throwable t ) { //1
			if ( RunTime.isThisWrappedException_of_thisType( t, BadCallError.class ) ) { //2
				//yes it is exactly BadCallError 
				//first clear the just caught exception and all its wraps, previously thrown exceptions will(should) remain active, 
				//so later when seeing the list of exceptions in eclipse,
				//you won't see this exception we just handled here
				RunTime.clearLastThrown_andAllItsWraps();//3
				
				//...process the above IF as if it were true..
				//...code here
				//...
				//4
			}else {//else don't clear it 'cause it's something else - unexpected
				RunTime.throWrapped(t);//5 rethrow here, signaling that it wasn't any of the above in the IFs
			}
	} 
	NOTE: that you cannot test for a subclass of ie. Error, you can only test specifically for the named class (though it's easy to make a method for this, will do when needed)
	
	alternatively (if there is more than one test in the catch you should use the following instead):
	try {
			try {
				Factory.init( ml2, params1 );//assuming this throws an already wrapped BadCallError - no matter in how many layers of wraps
			} catch ( Throwable t ) {
				RunTime.throWrapped( t );//we wrap it again just for fun; doesn't need to be wrapped at all actually, can contain zero wraps
			}
	} catch ( Throwable t ) { //1
			Class<? extends Throwable> unwrappedLastThrownOne = RunTime.getUnwrappedExceptionNeverNull( t ).getClass();//2
			
			//the following code (when testing for what was thrown) may throw depending on what you call
			
			if (BadCallError.class == unwrappedLastThrownOne) {
				//yes it is exactly BadCallError
				RunTime.clearLastThrown_andAllItsWraps();//3
				
				//handle IF normally after this:
				//...code that might throw new exceptions which we want reported
			} else
			if (Exception.class == unwrappedLastThrownOne) {
				//yes it is exactly Exception
				RunTime.clearLastThrown_andAllItsWraps();//3
				
				//handle IF normally after this:
				//...code that might throw new exceptions which we want reported
			} else
			if (Error.class == unwrappedLastThrownOne) {
				//yes it is exactly Error, note that although BadCallError extends Error, if you caught BadCallError above, you will NOT catch it here as just Error.class
				//why? because this only tests for exactly that specific exception, no subclass or superclass of it!
				RunTime.clearLastThrown_andAllItsWraps();//3
				
				//handle IF normally after this:
				//...code that might throw new exceptions which we want reported
			} else {
					//4
					RunTime.throWrapped(t); //4 rethrow because it wasn't any of the above IFs
			}
	}
	
6. any classes that want to have init and deInit of resources ie. db-related should inherit Initer class and use Factory class to get new instance and init it and should use
   try, catch, finally block to make sure those resources are deInited in the proper order; NOTE: deInitAll() cannot be implemented and should not be attempted again

7. nothing is thread safe, unless explicitly specified.

8. to enable call tracing on System.err set RunTime.callTracingFromHere to true and when done set it to false, works at runtime but make sure call tracing is enabled in the aspect
and yeah you must be using AspectJ (plugin in eclipse) RecursionDetector.aj file at the time of this writting.

9. for recursion detection RunTime.recursiveLoopDetected if is true in the method testing it, then that method is in recursion, that is, it is itself one of the active parent 
callers in stack at the time of this call - so it's been called at least twice, the latter being currently; however if you call another method from within this method, then 
RunTime.recursiveLoopDetected might be false if that method is itself not in recursion-state that is it didn't end up called again while in itself
- in either case enableRecursionDetection must be true in the RecursionDetector.aj aspect for the recursion tracing to be enabled, but beware that this takes lots of time 
  for example 9 seconds of jUnit tests get as high as 131seconds with recursion enabled :)
  
10. do not manually name any of your methods ending with _aroundBody[0-9]+ or with that+"$advice" , those are what the aspect around adivce uses for its methods internally

11. look on console for exceptions thrown at what line/file, because in eclipse trace they seem off by 1 line(usually lacking back 1 line) and on console they are shown 
in the order they occurred.
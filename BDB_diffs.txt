bdb-native aka DB
bdb java edition aka JE
bdb-native via jni aka JNI

see 5. , you can use only one of: bdb-native or bdbje, not both at the same time; java limitation

some quotes from the web, to identify some of the differences between BDB variants:
ie. from here: http://dbaspot.com/berkeley-db/265171-java-jni-api-versus-java-edition.html
and here: http://download.oracle.com/docs/cd/E17076_02/html/programmer_reference/am_conf_select.html

1. DB is file+log and JE is log-only.
The JNI will be a factor, copying bytes in and out is not cheap.

Due to the fact that DB is written for the LCD in a ANSI C world
threads were not available. That and the difference in architecture
between the products lead to the 5% difference in API and
implementation when switching between the two products (DB Java/JNI and
BDB JE).

"The architecture is based on a log-based, no-overwrite storage system, enabling high concurrency and speed while providing ACID 
transactions and record-level locking."
"Record level locking for high concurrency"
from: http://www.oracle.com/technetwork/database/berkeleydb/overview/index-093405.html 

2. Berkeley DB XML is written entirely in C++ as a layer on top of Berkeley DB.
to use BDB XML you must go the native route and use DB

3. there is more house keeping for your application to do when you use DB.

4. there are a few times when you absolutely must use Btree:

    If you want to use bulk put and get operations.

    If having your database clustered on sort order is important to you.

    If you want to be able to create records using cursors.

    If you have multiple threads/processes simultaneously creating new records, and you want to be able to efficiently iterate 
    over those records using a cursor.

But beyond those limitations, there are some application characteristics that should cause you to suspect that Heap will work 
better for your application than Btree. They are:

    Your application will run in an environment with constrained resources and you want to set a hard limit on the size of the 
    database file.

    You want to limit the disk space growth of your database file, and your application performs a roughly equivalent number of 
    record creations and deletions.

    Inserts into a Btree require sorting the new record onto its proper page. This operation can require multiple page reads. 
    A Heap database can simply reuse whatever empty page space it can find in the cache. Insert-intensive applications will
     typically find that Heap is much more efficient than Btree, especially as the size of the database increases.

the Btree access method should be used when there is any locality of reference among keys. Locality of reference means that 
accessing one particular key in the Btree implies that the application is more likely to access keys near to the key being
 accessed, where "near" is defined by the sort order. For example, if keys are timestamps, and it is likely that a request for 
 an 8AM timestamp will be followed by a request for a 9AM timestamp, the Btree access method is generally the right choice.
 
there is no locality of reference for the Hash access method, and so key "AAAAA" is as likely to be stored on the same database 
 page with key "ZZZZZ" as with key "AAAAB" 
In the Btree access method, because items are sorted, key "AAAAA" is far more likely to be near key "AAAAB" than key "ZZZZZ"


5. cannot use both db.jar (from JNI) and je-4.1.10.jar (from bdb je) at the same time in the same app, due to them having defined
the same package name:
import com.sleepycat.bind.tuple.*;

thus:
The method stringToEntry(String, DatabaseEntry) in the type StringBinding is not applicable for the arguments 
(String, DatabaseEntry)

6. from my own tests, 
in bdb-native(using a .dll or .so library directly from java via jni), btree is 4.4 times faster than hash
and bdb je is 1.45 times slower than bdb-native via jni
bdb je(pure 100% java implementation of bdb) only knows btree btw

7. bdb je doesn't know nested transactions, but bdb jni does;

8. really? cmon
when CDB is enabled/in-use
As a consequence of the Berkeley DB Concurrent Data Store locking model, the following sequences of operations will cause a 
thread to block itself indefinitely:

    Keeping a cursor open while issuing a DB->put() or DB->del() access method call.
    Attempting to open a write cursor while another cursor is already being held open by the same thread of control. Note that 
it is correct operation for one thread of control to attempt to open a write cursor or to perform a non-cursor write 
(DB->put() or DB->del()) while a write cursor is already active in another thread. It is only a problem if these things are 
done within a single thread of control -- in which case that thread will block and never be able to release the lock that is 
blocking it.
    Not testing Berkeley DB error return codes (if any cursor operation returns an unexpected error, that cursor must still be 
closed).

     Berkeley DB Concurrent Data Store groups use a TXN handle to indicate the shared locker ID to Berkeley DB calls, and call 
DB_TXN->commit() to end the group. This is a convenient way to pass the locked ID to the calls where it is needed, but should 
not be confused with the real transactional semantics provided by Berkeley DB Transactional Data Store. In particular, Berkeley 
DB Concurrent Data Store groups do not provide any abort or recovery facilities, and have no impact on durability of operations.

9. as I've noticed:
 with bdb JE a lock happens on a per record basis, in bdb native/jni on a per page basis ie. locking LockMode.RMW first record 
will also lock at least 100 of consecutive ones, but not 1000 of them.

